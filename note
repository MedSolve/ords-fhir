    /**
     * Hidden but used for speed of valueset querying
     */
    public _quickScopeValues: SchemaModels.Valueset = {};
        // create quickScope of values
        // obs: Only works for codeSystem right now
        let paths: any = this.codeSystem;
        let tmpPath: string;

        // find recrusivly the code system concept 
        function recrusive(coding: any, path: string): void {

            // read the concept
            Object.keys(coding.concept).forEach((value: any, index: number) => {
                
                // keep reference
                this._quickScopeValues[path + '.' + value.code] = value;

                // deep search for other concepts
                if (value.concept !== undefined) {
                    tmpPath = path + '.' + value.code;
                    recrusive(value, tmpPath);
                }
            });
        }

        Object.keys(paths.concept).forEach((value: any, index: number) => {

            // keep reference
            this._quickScopeValues[value.code] = value;

            // deep search for other concepts
            if (value.concept !== undefined) {

                tmpPath = value.code;
                recrusive(value, tmpPath);
            }
        });

        /**
     * Validates if value is within the valueset
     * @param   {any}     value       value to be looked for in dataset
     * @returns {bolean}  the indication of the presence of that value in the dataset
     */
    public isInValueSet(value: string, strength: SchemaModels.BindingStrength): boolean {

        // obs: Only works for codeSystem right now

        let searchPaths: Array<string> = value.split('.');

        // check every entry in the code system (THIS IS SLOW) do something better
        function recrusive(path: any): boolean {

            let needle: any = searchPaths.shift();
            let feedback: boolean = false;
            let concept: any;

            path.concept.every((data: any) => {

                // if code match and is not abstract
                if (data.code === needle && data.abstract === false) {
                    feedback = true;
                    concept = data.concept;
                    return false;
                    // else keep searching
                } else {
                    return true;
                }
            });

            // continue sub search if needed
            if (feedback === true && searchPaths.length !== 0) {

                // no more searches are possible
                if (concept === undefined) {
                    return false;
                }

                return recrusive(concept);
            }

            return feedback;
        }

        return recrusive(this.codeSystem);

    }